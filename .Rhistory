x <- data.frame(Age = c(25,30,35,40), Working = c(T, T, F, F))
x
str(x)
nrow(x)
ncol(x)
names(x)
x$Age
# Another Example
y <- data.frame(SN = 1:2, Age = c(21,15), Name = c("John","Dora"))
y
"
y
# Another Example
y <- data.frame("SN" = 1:2, "Age" = c(21,15), "Name" = c("John","Dora"))
y
y[2,2]
# Definition of vectors
name <- c("Mercury", "Venus", "Earth", "Mars", "Jupiter", "Saturn", "Uranus", "Neptune")
type <- c("Terrestrial planet", "Terrestrial planet", "Terrestrial planet",
"Terrestrial planet", "Gas giant", "Gas giant", "Gas giant", "Gas giant")
diameter <- c(0.382, 0.949, 1, 0.532, 11.209, 9.449, 4.007, 3.883)
rotation <- c(58.64, -243.02, 1, 1.03, 0.41, 0.43, -0.72, 0.67)
rings <- c(FALSE, FALSE, FALSE, FALSE, TRUE, TRUE, TRUE, TRUE)
# Create a data frame from the vectors
planets_df <- data.frame(name,type,diameter,rotation,rings)
rings <- c(FALSE, FALSE, FALSE, FALSE, TRUE, TRUE, TRUE, TRUE, FALSE)
# Create a data frame from the vectors
planets_df <- data.frame(name,type,diameter,rotation,rings)
rings <- c(FALSE, FALSE, FALSE, FALSE, TRUE, TRUE, TRUE, TRUE)
# Create a data frame from the vectors
planets_df <- data.frame(name,type,diameter,rotation,rings)
planets_df
# Print out diameter of Mercury (row 1, column 3)
planets_df[1,3]
# Print out data for Mars (entire fourth row)
planets_df[4,]
planets_df[1:3,2]
planets_df[1:3,"type"]
#### Select first 5 values of diameter column
planets_df[1:5,"diameter"]
planets_df[,3]
planets_df[,"diameter"]
# There is a short-cut for above command. If your columns have names, you can use the $ sign to fetch all the values:
planets_df$diameter
first_list <- list("a" = c(1, 2, 3), "b" = TRUE, "c" = 20)
first_list
data.frame(first_list)
# Subsetting elements of a list
# When we use â[ ]â to subset a list, we get an object of the list type with the element at the specified position
first_list[1]
first_list[2]
first_list[3]
# Subsetting elements of a list
# When we use â[ ]â to subset a list, we get an object of the list type with the element at the specified position
first_list[1][1]
# Subsetting elements of a list
# When we use â[ ]â to subset a list, we get an object of the list type with the element at the specified position
first_list[1,1]
# Subsetting elements of a list
# When we use â[ ]â to subset a list, we get an object of the list type with the element at the specified position
first_list[1]
# Another Example
# Vector with numerics from 1 up to 10
my_vector <- c(1:10)
# Matrix with numerics from 1 up to 9
my_matrix <- matrix(1:9, ncol = 3)
my_matrix
# Matrix with numerics from 1 up to 9
my_matrix <- matrix(1:9, nrow  = 3)
my_matrix
# Matrix with numerics from 1 up to 9
my_matrix <- matrix(1:9, nrow  = 3)
my_matrix
# Print out built-in R data frame
mtcars
dim(mtcars)
# Investigate the structure of mtcars
str(mtcars)
# First 10 elements of the built-in data frame mtcars
my_df <- mtcars[1:10,]
my_df
my_list <- list(my_vector,my_matrix,my_df)
my_list
# Adapt list() call to give the components names
names(my_list) <- c("vec","mat","df")
# Print out my_list
my_list
# if statement
x = 1
# if statement
x = 1
if (x==2){
print("Yo")
}else{
print("NOpe")
}
x = 0
if (x < 0) {
print("Negative number")
} else if (x > 0) {
print("Positive number")
} else
print("Zero")
x = 0
if (x < 0) {
print("Negative number")
} else if (x > 0) {
print("Positive number")
} else{
print("Zero")
}
ifelse(x==0 , "yo","no")
# ifelse() function
a = c(5,7,2,9)
# ifelse() function
a = c(5,7,2,9)
z =c(ifelse(a %% 2 == 0, "even", "odd"))
z
x = c(2, 5, 3, 9, 8, 11, 6)
count = 0
x = c(2, 5, 3, 9, 8, 11, 6)
count = 0
ifelse(x%%2 == 0, count+=1, count =0)
x[x%%2 ==0]
sum(x[x%%2 ==0])
length(x[x%%2 ==0])
for (val in x) {
if(val %% 2 == 0)
count = count+1
print(count)
}
count
length(x[x%%2 ==0])
x = c(1,5,7,8,4,2,44,2,3,5,2,4,5,6,7,8,89,2, 5, 3, 9, 8, 11, 6)
count = 0
for (val in x) {
if(val %% 2 == 0)
count = count+1
}
count
length(x[x%%2 == 0])
# while loop
i = 1
while (i < 6) {
print(i)
i = i+1
}
# break statement
x = 1:5
for (val in x) {
if (val == 3){
break
}
print(val)
}
for (val in x) {
if (val == 3){
break
}
print(val)
}
for (val in x) {
if (val == 3){
break
}else{
print(val)
}
}
x <- factor(c("1", "2", "2", "1","1","2","1","2","2"))
x
x <- c("1", "2", "2", "1","1","2","1","2","2")
x
x <- factor(c("1", "2", "2", "1","1","2","1","2","2"))
x
# Category vector
category_vector <- c("Male", "Female", "Female", "Male", "Male")
# Convert Category_vector to a factor
factor_category_vector <- factor(category_vector)
# Print out factor_category_vector
factor_category_vector
# Temperature
temperature_vector <- c("High", "Low", "High","Low", "Medium")
temperature_vector <- c("High", "Low", "High","Low", "Medium")
factor_temperature_vector <- factor(temperature_vector,
order = TRUE,
levels = c("Low", "Medium", "High"))
factor_temperature_vector
# Create speed_vector
speed_vector <- c("medium", "slow", "slow", "medium", "fast")
# Convert speed_vector to ordered factor vector
factor_speed_vector <- factor(speed_vector,
order=TRUE,
levels = c("slow","medium","fast"))
# Print factor_speed_vector
factor_speed_vector
summary(factor_speed_vector)
str(factor_speed_vector)
# Factor value for second data analyst
da2 <- factor_speed_vector[2]
da2
# Factor value for fifth data analyst
da5 <- factor_speed_vector[5]
da5
# Is data analyst 2 faster than data analyst 5?
da2>da5
v =c(98, 82, 102, 99, 100)
v[1]
v[1,5]
v[1,2]
v[1:5]
v[1,5,1]
v[c(1,5)]
v[c(1)]
#' * Question 2: Create a vector containing a sequence of numbers in the interval
#'  of 40 to 1000, separated by 10. Find the length of the vector.
v = seq(40,1000,by=10 )
v
#' * Question 2: Create a vector containing a sequence of numbers in the interval
#'  of 40 to 1000, separated by 10. Find the length of the vector.
length(seq(40,1000,by=10 ))
#' * Question 3: Create a vector containing a sequence of numbers in the interval of
#'  1 to 2500, separated by 6 and subset the first 50 elements of the vector
c(1,2500,by=6)[:50]
#' * Question 3: Create a vector containing a sequence of numbers in the interval of
#'  1 to 2500, separated by 6 and subset the first 50 elements of the vector
v = c(1,2500,by=6)
v[1:50]
v[seq(1:50)]
#' * Question 3: Create a vector containing a sequence of numbers in the interval of
#'  1 to 2500, separated by 6 and subset the first 50 elements of the vector
v = seq(1,2500,by=6)
v[seq(1:50)]
len(v[seq(1:50)])
len(v[c(1:50)])
len(v[c(:50)])
length(v[seq(1:50)])
v[seq(1:50)]
#' * Question 3: Create a vector containing a sequence of numbers in the interval of
#'  1 to 2500, separated by 6 and subset the first 50 elements of the vector
v = seq(1,2500,by=6)
v[seq(1:50)]
v
v[50]
v1 = c(3, 4, 5, 7)
v2 = c(6, 9, 12, 15, 18, 21)
v1+v2
v1-v2
v2+v1
v2-v1
#' * Question 5: Multiply c(34, 43, 22, 43) and c(13, 17)
c(34, 43, 22, 43) * c(13, 17)
v1 = seq(1:10)
v2 = seq(11:20)
matrix(seq(21:40),cbind(v1,v2))
v3 = seq(21:40)
matrix(v3,cbind(v1,v2))
v4 = cbind(v1,v2)
matrix(v3,v4)
matrix(data = seq(21:40))
v4 = cbind(v1,v2)
v4
v4 =
cbind(cbind(v1,v2), matrix(data = seq(21:40)))
v4
cbind(cbind(v1,v2), matrix(data = seq(21:40),nrow = 10, ncol = 2 ))
mat = matrix(data = seq(21:40),nrow = 10, ncol = 2 )
mat
mat = matrix(data = seq(from = 21, to = 40),nrow = 10, ncol = 2 )
mat
cbind(v4 , mat )
v2 = seq(from = 11, to = 20)
v4 = cbind(v1,v2)
mat = matrix(data = seq(from = 21, to = 40),nrow = 10, ncol = 2 )
cbind(v4 , mat )
v2 = seq(11, 20)
v2
#'
#' * Question 6: Create two vectors of sequence 1 to 10 and 11 to 20;
#' column bind these vectors; Now create a matrix containing data from 21 to 40
#' and column bind that matrix to the resultant matrix of the first operation.
v1 = seq(1,10)
1:10
11:20
vz = 11:20
vz
v1 = seq(1,10)
v2 = seq(11, 20)
v4 = cbind(v1,v2)
mat = matrix(data = seq(from = 21, to = 40),nrow = 10, ncol = 2 )
mat
cbind(v4 , mat )
my_list <- list("first_element" = F,
"second_element" = matrix(data = 1:6, nrow = 2, ncol = 3),
"third_element" = 20:200)
my_list[2]
my_list[3]
class(my_list[1])
class(my_list[1] == T)
my_list[1] == T
class(my_list[1] == T)
#'
#'
#' * Question 8: Create a data frame with two columns using the data.frame()
#' function. First column should contain characters, second column should contain
#'  numeric objects. The columns should be assigned valid names.
data.frame(char = c('dff','dsd','ewew'), num = c(1,2,3))
#' * Question 9: Create a data frame with one column as a squence of numbers
#' between 1 to 50, the other being from 51 to 100; After creating the data frame
#' change the column names to "column1" and "column2"
data.frame(1:50, 51:100 )
colnames(z)
head(z)
#' * Question 9: Create a data frame with one column as a squence of numbers
#' between 1 to 50, the other being from 51 to 100; After creating the data frame
#' change the column names to "column1" and "column2"
z = data.frame(1:50, 51:100 )
head(z)
z = data.frame(1:50, 51:100 )
colnames(z) = c('1:50', '51:100')
head(z)
getwd()
setwd("C:\Users\Python\Desktop")
```{r}
setwd("C:/Users/Python/Desktop")
getwd()
mtcars = read.csv(file = "mtcars.csv",header=TRUE,sep=",")
```{r}
setwd("C:\Users\Python\Desktop\Insofe_Class_Notes\20180603")
setwd("C:/Users/Python/Desktop/Insofe_Class_Notes/20180603")
mtcars = read.csv(file = "mtcars.csv",header=TRUE,sep=",")
class(mtcars)
head(mtcars)
colnames(mtcars)
str(mtcars)
mtcars = read.csv(file = "mtcars.csv",header=TRUE,sep=",",stringsAsFactors = F )
head(mtcars)
str(mtcars)
mtcars = read.csv(file = "mtcars.csv",header=TRUE,sep=",",stringsAsFactors = T )
str(mtcars)
head(mtcars)
str(mtcars)
summary(mtcars)
summary(mtcars).T
transpose(summary(mtcars))
colnames(mtcars)
rownames(mtcars)
head(mtcars)
rownames(mtcars) = mtcars$X
rownames(mtcars)
mtcars
mtcars$X=NULL
mtcars
colnames(mtcars)[6] = "weight"
mtcars
# Data type of the Column checked by is.* will return in a logical vector of
# length 1
is.numeric(mtcars$Cars)
is.character(mtcars$hp)
# Data type of the Column checked by is.* will return in a logical vector of
# length 1
is.character(mtcars$Cars)
mtcars$Cars
is.numeric(mtcars$hp)
str(mtcars)
mtcars[,c(1,11)]
mtcars[,1:11)]
mtcars[,seq(1:11)]
mtcars[,seq(1:5)]
mtcars[,seq(1,5)]
mtcars[,c(1,5)]
mtcars[,(1,5)]
mtcars[,c(1,5)]
class(mtcars[,c(1,11)])
rownames(mtcars)
mtcars['Duster 360',]
rownames(mtcars)
mtcars['Duster 360',]
class(mtcars['Duster 360',])
mtcars[7,]
mtcars['Duster 360',]
indices(mtcars['Duster 360',])
mtcars[7,]
class(mtcars[7,])
mtcars[c(6,7),]
class(mtcars[c(6,7),])
#Subsetting data
s1 <-subset(mtcars,select=c(cyl,mpg))
s1
mtcars[c('Duster 360','Valiant'),c('mpg','hp')]
class(mtcars[c('Duster 360','Valiant'),c('mpg','hp')])
mtcars[c(6,7),c(1,2)]
class(mtcars[c(6,7),c(1,2)])
colsum=c()
colsum=c()
for (i in colnames(mtcars)){
sum = 0
for (j in mtcars[,i])
{
if(is.na(j)==TRUE)
{
sum = sum+1
}else
{
sum = sum
}
}
colsum[i] = sum
}
colsum
colSums(is.na(mtcars))
is.na(mtcars)
colSums(is.na(mtcars))
sum(is.na(mtcars))
rowSums(is.na(mtcars))
mtcars_imputed  = centralImputation(mtcars)
library(DMwR)
mtcars_imputed  = centralImputation(mtcars)
colSums(is.na(mtcars_imputed))
mtcars_imputed$pwr <-mtcars_imputed$hp/mtcars_imputed$weight
head(mtcars_imputed)
mtcars_imputed $hp
# After looking the numbers we can get the idea of how to bin them
bins = cut(mtcars_imputed $hp,breaks = seq(0,500,20),include.lowest = T,right = T)
bins
# Count the number of rows that comes under a particular bin
table(bins)
library(dummies)
dummy(mtcars_imputed$vs)
mtcars = read.csv(file = "mtcars.csv",header=TRUE,sep=",",stringsAsFactors = T )
mtcars = read.csv(file = "mtcars.csv",header=TRUE,sep=",",stringsAsFactors = T )
summary(mtcars)
str(mtcars)
as.numeric(mtcars$mpg)
as.numeric(mtcars$mpg)
is.numeric(mtcars$mpg)
colnames(is.na(mtcars))
colnames(is.na(mtcars))
colSums(is.na(mtcars))
library(infotheo)
(nbins = floor(sqrt(NROW(mtcars_imputed $hp))))
discretize(mtcars_imputed $hp,disc = "equalwidth",nbins)
discretize(mtcars_imputed $hp,disc = "equalfreq",nbins)
library(vegan)
mtcars_imputed_standardized <- decostand(x =mtcars_imputed[,c('mpg','disp','drat','weight','qsec','gear','carb')],method ="standardize",MARGIN = 2)
str(mtcars_imputed_standardized)
knitr::opts_chunk$set(echo = TRUE)
setwd("C:\Users\Python\Documents\GitHub\data_preprocessing_steps_R-Python")
setwd("C:/Users/Python/Documents/GitHub/data_preprocessing_steps_R-Python")
dataframe = read.csv(file = "" , header=TRUE , sep="," , stringsAsFactors = F ,  na.strings="NA" )
dataframe = read.csv(file = "mtcars.csv" , header=TRUE , sep="," , stringsAsFactors = F ,  na.strings="NA" )
dataframe
head(dataframe)
summary(dataframe)
str(dataframe)
colnames(dataframe)
rownames(dataframe) = dataframe$X
dataframe$X=NULL
head(dataframe)
colnames(dataframe)
head(dataframe)
sapply(dataframe, class)
# For individual column check:
is.numeric(dataframe$mpg)
# For individual column check:
print (is.numeric(dataframe$mpg))
sapply(dataframe, class)
# For individual column check:
print (is.numeric(dataframe$mpg))
sapply(dataframe, class)
as.numeric(dataframe$mpg)
# There are many ways for this approach but the most efficient is
# using the colSums which is a built in dataframe function
colSums(is.na(dataframe))
sum(is.na(dataframes))
sum(is.na(dataframe))
library(DMwR)
df_imputed  = centralImputation(dataframe)
sum(is.na(df_imputed))
# One way to figure out a categorical column is using bulitin str function.
str(dataframe)
# One way to figure out a categorical column is using bulitin str function.
table(dataframe)
# One way to figure out a categorical column is using bulitin str function.
table(dataframe$vs)
# One way to figure out a categorical column is using bulitin str function.
str(dataframe)
range(mtcars_imputed_standardized$mpg)
dummy(dataframe$vs)
head(dummy(dataframe$vs))
library(vegan)                                                              dataframe_generalized = decostand(x = dataframe[,
library(vegan)                                                              dataframe_generalized = decostand(x = dataframe[,
library(vegan)
library(vegan)                                                              dataframe_generalized = decostand(x = dataframe[,
library(vegan)
library(vegan)                                                              dataframe_generalized = decostand(x = dataframe[,
colnames(dataframe)
dataframe_generalized = decostand(x = dataframe[,
c('mpg','disp','drat','wt','qsec','gear','carb')],
method = "range",MARGIN = 2)
dataframe_generalized = decostand(x = df_imputed[,
c('mpg','disp','drat','wt','qsec','gear','carb')],
method = "range",MARGIN = 2)
dataframe_standardized = decostand(x =df_imputed[ ,
c('mpg','disp','drat','wt','qsec','gear','carb')],                          method ="standardize",MARGIN = 2)
head(dataframe_generalized)
head(dataframe_generalized)
head(dataframe_standardized)
table(dummy_values_vs)
str(dummy_values_vs)
dummy_values_vs = dummy(dataframe$vs)
str(dummy_values_vs)
table(dummy_values_vs)
